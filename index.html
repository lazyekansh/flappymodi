<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Flappy Modi Ji</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: #000;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
    }

    /* Fullscreen container */
    #gameContainer {
      position: fixed;
      inset: 0;
      background: #000;
    }

    /* Canvas is logically 400x600 but visually fills screen */
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    #ui {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      text-align: center;
    }

    .big-text {
      font-size: 32px;
      font-weight: 700;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
      margin-bottom: 8px;
    }

    .small-text {
      font-size: 16px;
      opacity: 0.9;
    }

    #scoreDisplay {
      position: fixed;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 24px;
      font-weight: 700;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      pointer-events: none;
    }

    #bestScoreDisplay {
      position: fixed;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 14px;
      opacity: 0.85;
      pointer-events: none;
    }

    .tagline {
      margin-top: 10px;
      border-radius: 999px;
      padding: 6px 14px;
      font-size: 13px;
      border: 1px dashed rgba(255, 255, 255, 0.7);
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(4px);
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <!-- Logical size stays 400x600, CSS stretches it -->
    <canvas id="gameCanvas" width="400" height="600"></canvas>

    <div id="scoreDisplay">0</div>
    <div id="bestScoreDisplay">Best: 0</div>

    <div id="ui">
      <div class="big-text" id="titleText">Tap to Start</div>
      <div class="small-text" id="subText">Tap / Click / Space to flap</div>
      <div class="tagline">Flappy Modi Ji</div>
    </div>
  </div>

  <script>
    // ===== CANVAS SETUP (fixed 400x600 game world) =====
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const W = canvas.width;   // 400
    const H = canvas.height;  // 600

    // ===== GAME STATE =====
    let gameState = "ready"; // "ready", "playing", "over"

    // ===== BIRD =====
    const bird = {
      x: W * 0.25,
      y: H / 2,
      radius: 18,
      vy: 0,
      gravity: 0.35,
      jumpStrength: -7
    };

    // ===== PIPES =====
    const pipes = [];
    const pipeWidth = 55;
    const pipeGap = 160;
    const pipeSpeed = 2.6;
    let pipeSpawnTimer = 0;
    const pipeSpawnInterval = 95;

    // ===== SCORE =====
    let score = 0;
    let bestScore = 0;

    // ===== IMAGES (OPTIONAL) =====
    const bgImage = new Image();
    const groundImage = new Image();
    const birdImage = new Image();
birdImage.src = "https://iili.io/fxANpiG.jpg";
    // ðŸ‘‰ Put your own images in same folder or /images and set src:
    // birdImage.src = "modi.png";
    // bgImage.src = "bg.png";
    // groundImage.src = "ground.png";

    // ===== START SOUND ONLY =====
    // audio/start.mp3 must exist in "audio" folder next to index.html
    const startSound = new Audio("audio/start.mp3");
    startSound.volume = 1;

    // ===== INPUT / FLAP =====
    function flap() {
      if (gameState === "ready") {
        resetGame();
        gameState = "playing";
        bird.vy = bird.jumpStrength;

        const uiEl = document.getElementById("ui");
        if (uiEl) uiEl.style.display = "none";

        // play start sound once
        startSound.currentTime = 0;
        startSound.play().catch(() => {});
      }
      else if (gameState === "playing") {
        bird.vy = bird.jumpStrength; // no sound
      }
      else if (gameState === "over") {
        resetGame();
        gameState = "ready";

        const uiEl = document.getElementById("ui");
        if (uiEl) uiEl.style.display = "flex";
      }
    }

    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        flap();
      }
    });

    canvas.addEventListener("mousedown", flap);
    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      flap();
    });

    // ===== GAME FUNCTIONS =====
    function resetGame() {
      bird.y = H / 2;
      bird.vy = 0;
      pipes.length = 0;
      pipeSpawnTimer = 0;
      score = 0;
      updateScoreDisplay();

      document.getElementById("titleText").textContent = "Tap to Start";
      document.getElementById("subText").textContent = "Tap / Click / Space to flap";
    }

    function spawnPipe() {
      const minTop = 70;
      const maxTop = H - 70 - pipeGap;
      const topHeight = Math.floor(Math.random() * (maxTop - minTop + 1)) + minTop;

      pipes.push({
        x: W + 20,
        top: topHeight,
        passed: false
      });
    }

    function endGame() {
      if (gameState !== "over") {
        gameState = "over";
        document.getElementById("titleText").textContent = "Game Over";
        document.getElementById("subText").textContent = "Tap / Click / Space to restart";
      }
    }

    function updateScoreDisplay() {
      document.getElementById("scoreDisplay").textContent = score;
      document.getElementById("bestScoreDisplay").textContent = "Best: " + bestScore;
    }

    // ===== DRAW HELPERS =====
    function drawBackground() {
      if (bgImage.src) {
        ctx.drawImage(bgImage, 0, 0, W, H);
      } else {
        const grad = ctx.createLinearGradient(0, 0, 0, H);
        grad.addColorStop(0, "#5ee7ff");
        grad.addColorStop(1, "#2e86de");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);
      }
    }

    function drawGround() {
      const groundHeight = 60;
      const y = H - groundHeight;

      if (groundImage.src) {
        ctx.drawImage(groundImage, 0, y, W, groundHeight);
      } else {
        ctx.fillStyle = "#3b3b3b";
        ctx.fillRect(0, y, W, groundHeight);
        ctx.fillStyle = "#2e2e2e";
        ctx.fillRect(0, y + 10, W, 4);
      }
    }

    function drawBird() {
      if (birdImage.src) {
        const size = bird.radius * 2;
        ctx.save();
        ctx.translate(bird.x, bird.y);
        ctx.rotate(Math.min(Math.max(bird.vy / 10, -0.5), 0.5));
        ctx.drawImage(birdImage, -size / 2, -size / 2, size, size);
        ctx.restore();
      } else {
        ctx.save();
        ctx.translate(bird.x, bird.y);
        ctx.beginPath();
        ctx.arc(0, 0, bird.radius, 0, Math.PI * 2);
        ctx.fillStyle = "#ffce00";
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#00000055";
        ctx.stroke();

        // eye
        ctx.beginPath();
        ctx.arc(5, -4, 4, 0, Math.PI * 2);
        ctx.fillStyle = "#fff";
        ctx.fill();
        ctx.beginPath();
        ctx.arc(6, -4, 2, 0, Math.PI * 2);
        ctx.fillStyle = "#000";
        ctx.fill();

        // beak
        ctx.beginPath();
        ctx.moveTo(bird.radius, 0);
        ctx.lineTo(bird.radius + 10, 4);
        ctx.lineTo(bird.radius + 2, -2);
        ctx.closePath();
        ctx.fillStyle = "#ff8c00";
        ctx.fill();

        ctx.restore();
      }
    }

    function drawPipes() {
      for (const p of pipes) {
        const topHeight = p.top;
        const bottomY = p.top + pipeGap;

        ctx.fillStyle = "#24c64f";

        // top pipe
        ctx.fillRect(p.x, 0, pipeWidth, topHeight);
        ctx.fillRect(p.x - 4, topHeight - 18, pipeWidth + 8, 18);

        // bottom pipe
        const bottomHeight = H - bottomY - 40;
        ctx.fillRect(p.x, bottomY, pipeWidth, bottomHeight);
        ctx.fillRect(p.x - 4, bottomY, pipeWidth + 8, 18);
      }
    }

    function draw() {
      drawBackground();
      drawPipes();
      drawGround();
      drawBird();
    }

    // ===== MAIN LOOP =====
    function update() {
      if (gameState === "playing") {
        bird.vy += bird.gravity;
        bird.y += bird.vy;

        // top / ground collision
        if (bird.y - bird.radius < 0 || bird.y + bird.radius > H - 40) {
          endGame();
        }

        // spawn pipes
        pipeSpawnTimer++;
        if (pipeSpawnTimer >= pipeSpawnInterval) {
          spawnPipe();
          pipeSpawnTimer = 0;
        }

        // move pipes, detect collisions & scoring
        for (let i = pipes.length - 1; i >= 0; i--) {
          const p = pipes[i];
          p.x -= pipeSpeed;

          const inPipeX = bird.x + bird.radius > p.x && bird.x - bird.radius < p.x + pipeWidth;
          const inTop = bird.y - bird.radius < p.top;
          const inBottom = bird.y + bird.radius > p.top + pipeGap;

          if (inPipeX && (inTop || inBottom)) {
            endGame();
          }

          if (!p.passed && p.x + pipeWidth < bird.x) {
            p.passed = true;
            score++;
            if (score > bestScore) bestScore = score;
            updateScoreDisplay();
          }

          if (p.x + pipeWidth < 0) {
            pipes.splice(i, 1);
          }
        }
      }

      draw();
      requestAnimationFrame(update);
    }

    // ===== START =====
    resetGame();
    update();
  </script>
</body>
</html>